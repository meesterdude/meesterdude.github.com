<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: feed | RuRu]]></title>
  <link href="http://meesterdude.github.com/categories/feed/atom.xml" rel="self"/>
  <link href="http://meesterdude.github.com/"/>
  <updated>2018-02-05T02:11:27-05:00</updated>
  <id>http://meesterdude.github.com/</id>
  <author>
    <name><![CDATA[Russell Jennings]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
    <entry>
      




<title type="html"><![CDATA[Introducing WillYou DidYou &rarr;]]></title>
<link href="/entries/introducing-willyou-didyou/"/>
<updated>2017-05-04T17:21:00-04:00</updated>
<id>http://meesterdude.github.com/entries/introducing-willyou-didyou</id>

      <content type="html"><![CDATA[<p>My latest project, two accountabilabuddies to help you achieve your goals. Add your Email address to the list!</p>

<!--more-->


<p><a rel="bookmark" href="http://meesterdude.github.com/entries/introducing-willyou-didyou/">&infin; Permalink</a></p>


<p><a rel="post-link" href="http://willyoudidyou.com">-> Link <-</a></p>

]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[3 words that changed me]]></title>
<link href="http://meesterdude.github.com/entries/3-words-that-changed-me/"/>
<updated>2017-03-21T00:22:00-04:00</updated>
<id>http://meesterdude.github.com/entries/3-words-that-changed-me</id>

      <content type="html"><![CDATA[<p>Words I've known, but did not understand or truly appreciate.</p>

<!--more-->


<p>It's not every day that a single, common word can change who you are. At least I imagine it isn't - I admit there might be people out there who see a word like "insulator" and become sheep herders - but I don't think this is such a case.</p>

<h2>Listen</h2>

<p>What does it mean, to listen? the absence of my mouth not moving? that's a simple enough definition, and the one I had for a while. But when you dive deeper, it's more than that.</p>

<p>To listen is to be quiet - verbally, and in mind. You can't listen when you're being strategic in your head about how to prove the other person wrong.</p>

<p>To listen is to be intently curious and unbiased in what you see - no matter how much you agree or disagree. The desire to understand outweighs the desire to judge. When you have a question, it's to know more, not to allude or infer.</p>

<p>And the best listeners are not tea cups you fill up with information - but mirrors that reflect what they observe - offering room for dispute on the facts, allowing them to better understand the other party.</p>

<h2>Cherish</h2>

<p>Growing up, I never understood a particular word that gets thrown around quite a lot in daily life. Certainly a function of my upbringing and experiences - I always felt the word "love" was hollow, an empty threat of compassion. Many of the least favorite people in my life had loved me - and expressed so in very creative ways.</p>

<p>But i think love makes a lot more sense, when paired with cherish. If love is the theory, cherish is the action. Of course you love your wife, your kids, your close friends; you would do anything for them, and maybe you already do. But love without cherishment is a campfire with no warmth.</p>

<p>Ironically, A great way to cherish is also to listen.</p>

<h2>Commitment</h2>

<p>I have a lot of goals, interests, ideas, todos, projects. I think a lot of us do. I've naturally accumulated them over the years in varying forms. Many I made progress on, and many more I did not.</p>

<p>But commitments. What do I have of those? I have a lease, which is a form of commitment, and a few other contracts and agreements.</p>

<p>But personally? What are mine? What have they ever been? It's not a word thats been in my vernacular, as a descriptor for a given interest, project, or idea. I've had many <a href="http://paidtoexist.com/go-all-out/">interests</a>, but no commitments.</p>

<p>What does it mean to be committed? It means accepting a fundamental change to who you are - changing your DNA as a person, flamboyantly. You have a mission and everything about you is geared towards it. The answer to every distraction becomes "I have a commitment".</p>

<p>People who are interested join the army reserves.
People who are committed join the army.</p>

<p><a rel="bookmark" href="http://meesterdude.github.com/entries/3-words-that-changed-me/">&infin; Permalink</a></p>



]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Upgrading rails to use strong_params automatically]]></title>
<link href="http://meesterdude.github.com/entries/upgrading-rails-to-use-strong-params-automatically/"/>
<updated>2015-11-30T08:15:00-05:00</updated>
<id>http://meesterdude.github.com/entries/upgrading-rails-to-use-strong-params-automatically</id>

      <content type="html"><![CDATA[<p>If you need to upgrade a rails app to rely on strong_params, getting all the attributes sorted out can be tedious and painful. But here I'll share with you a method that you can use to have most of the work done automatically. All you have to do is exercise your site, or have your test suite do it.</p>

<!--more-->


<h2>Installation</h2>

<p>Put the code (below) in <code>ApplicationController</code> and set a before_filter like <code>before_filter :install_strong_params, only: [:create, :update]</code>.</p>

<p>This code, when temporarily used within your project, will rewrite your controllers to use strong_params. It is not intelligent, and you may find you need to tweak the code or its output for it to work for your codebase; but it should carry you most of the way at least.</p>

<p>If you need to debug, uncomment the line that adds a params comment to the bottom of the controller.</p>

<p>Once your app has been upgraded, you should remove the code.</p>

<h2>Assumptions</h2>

<ul>
<li>a blank line preceeding the last line the controller, which should be an 'end' (typical for most apps)</li>
<li>existing create/update code is written using the symbol (params[:user] vs params['user'])</li>
<li>the first hash value found among the params is the one to use for strong_params (typical for most rails apps)</li>
<li>the params being submitted represent everything that should be allowed (not always the case with specs)</li>
</ul>


<h2>The Code</h2>

<p>```
 def install_strong_params</p>

<pre><code>path = self.class.instance_methods(false).map { |m| self.class.instance_method(m).source_location.first}.uniq.first
lines = File.open(path).read.lines
name, hash = params.detect{|k,v| v.is_a?(Hash) }
return true if hash.nil?
return true if lines.detect{|l| l.include?("#{name}_params")} # abort if already replaced
has_private = lines.detect{|l| l.include?('  private')}
# insert method defition at second to last line
lines[-2] = %Q^#{"  private \n\n" if !has_private}  def #{name}_params
params.require(:#{name}).permit(#{hash.keys.collect(&amp;:to_sym).to_s[1..-2]})
</code></pre>

<p>  end\n\n^</p>

<pre><code># lines[-1] = "end\n\n# #{params}" # uncomment to write params as comment at bottom of controller
lines.each_with_index do |l,i|
  lines[i] = l.gsub("params[:#{name}]", "#{name}_params") if l.include?("params[:#{name}]")
end
File.open(path, 'w+') { |file| file.write(lines.join) }
</code></pre>

<p>  end
```</p>

<p><a rel="bookmark" href="http://meesterdude.github.com/entries/upgrading-rails-to-use-strong-params-automatically/">&infin; Permalink</a></p>



]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[be kind &rarr;]]></title>
<link href="/entries/be-kind/"/>
<updated>2015-05-12T17:51:00-04:00</updated>
<id>http://meesterdude.github.com/entries/be-kind</id>

      <content type="html"><![CDATA[<p>Great advice, and something we could all do more.</p>

<!--more-->


<p><a rel="bookmark" href="http://meesterdude.github.com/entries/be-kind/">&infin; Permalink</a></p>


<p><a rel="post-link" href="http://boz.com/articles/be-kind.html">-> Link <-</a></p>

]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[How to raise a happy well-adjusted app: principles of software parenting]]></title>
<link href="http://meesterdude.github.com/entries/how-to-raise-a-happy-well-adjusted-app-principles-for-software-parenting/"/>
<updated>2015-05-10T03:06:00-04:00</updated>
<id>http://meesterdude.github.com/entries/how-to-raise-a-happy-well-adjusted-app-principles-for-software-parenting</id>

      <content type="html"><![CDATA[<p>Software is quickly born, but is slowly grown. Knowing how to raise software properly ensures continued return of investment, and prevents costly rewrites that can bankrupt you.</p>

<!--more-->


<h2>Philosophy</h2>

<h3>Software happiness is...</h3>

<p>Software happiness is the ability for an app to reach its full potential and maintain that state for years, ideally forever. It is its ability to remain agile in the short-term, as well as the long. And it is its ability to do this through the change of various hands of professionals over time.</p>

<h2>Why software happiness matters</h2>

<p>Businesses often build or sell software that becomes critical to their survival. But far too they become neglected and unmaintainable, sometimes to the point of requiring rewrite or in some extreme cases closing of the business.</p>

<h2>Principals</h2>

<h3>Love</h3>

<p>This is by far, the most important thing happy software needs, and lack of it is the leading cause of app health issues. Software that is not groomed and looked after regularly becomes black box or obese (usually both). Software needs someone to sit down with it and refine its inner workings regularly, if it is to remain nimble and agile throughout its years.</p>

<p>Software does not need unbounded amounts of love; But it does need a lot, and chances are good that your software could use more of it. These investments are harder to see the fruits of, and are not sexy. But without them, an app gone bad can take out an entire company.</p>

<h3>Mentoring</h3>

<p>As an app grows, it will usually acquire different needs and interests. Without guidance, these can cause serious damage to an app over time, and potentially make it too complicated to use. It is important, when designing a particular role or feature, to remain humble and curious. Far too often, people try to play the "my way" card. And while this card does work and has worked, it's not the right card for most people.</p>

<p>By far, it is better to listen to what others say, and make informed decisions from that. Although this isn't exclusively true either. Really, the issue isn't playing the "my way" card, its knowing when to. Sometimes, you will know better. Other times, you won't. It's important to know the difference, and change tactics to suite.</p>

<h3>Attention</h3>

<p>Not adding features to software can be as deadly as adding too many. While it's certainly possible that your app does not need anything else and has reached a state of "doneness", chances are good that there are optimizations and tweaks that could be made that would improve the utility of an app. When tastefully done, the resulting improvements can place you at the top.</p>

<p>However, not all changes are welcome. By far, the least popular change to an app is with its design. While sometimes this does improve the app and make it better, far too often changes are made that only serve to confuse or anger users. Which leads us to the next topic...</p>

<h3>Listening</h3>

<p>It's important to listen to what people say; the people who use your software, the ones who build it, and the market overall. They will often have valid suggestions or complaints that would be in the apps best interest to discuss. While how you react to their comments is the result of several factors, that you give them forum is the most important part.</p>

<p>actively not listening, has killed or at least effectively killed countless software projects.</p>

<h3>Vision</h3>

<p>Your well-adjusted software needs a purpose. Without it, it will meander off in different directions and likely not land anywhere useful. If you don't know what your software does, needs to do or could do, it can't get anywhere. Sometimes, wandering aimlessly leads to wonderful things; But usually it leads to death. If your software does wander about, it should do so with intent and measurement of performance and tuning. But once you've established what it needs to do today, you should think about tomorrow.</p>

<h3>Safety</h3>

<p>Security is a hard problem, and a hard sell. You could leave your front door unlocked tonight, and it probably wont matter. If you left it unlocked tomorrow night too, it still probably wouldn't matter. But one night, you'll leave it unlocked and it will matter. Or, you'll leave it locked, and it won't matter because someone broke in through your window.</p>

<p>The moral of the story is: If you do everything you can, you can stop the simple and easy security breaches; But at the same time, there many windows in a house, and you can't protect them all. If you're not taking a fort knox style approach to security, you should at least know whats at stake and how to react if something happens; though with software, there is the added need of detecting when something happens in the first place, as there is rarely broken glass found.</p>

<h3>Exercise</h3>

<p>Keeping your software in shape means exercising all of its parts regularly; both together and in isolation. This ensures your software performs as expected and is free of bugs. And while you can manually sit and exercise your app, it's usually prefered to write software that tests  software; especially under heavy &amp; active development. Writing these is the responsibility of the developers, and it is the responsibility of software parents to make sure it is taking place.</p>

<p>But sometimes exercises are redundant or pointless, and bugs are allowed to creep in. Or other times the test software is so poorly written, that it becomes unreliable or unwieldy. Or, maybe there are no tests written at all. Thankfully, All of these can be addressed using the love and listening principles, previously outlined.</p>

<h3>Discipline</h3>

<p>It is tempting of creatives to push their boundaries. Artists want bigger paintings, writers bigger stories, actors bigger movies. Developers and Designers are no different in this. Developers want to use new languages, databases or techniques, designers want to create impressive and definitive designs with new frameworks or syntax. And while these can and do lead to some impressive things, they far too often become a disability and a hinderance to the app. Tried and true solutions and approaches are boring, and there is always the temptation for something new. But boring is what makes happy software, so one must strike a balance between the two.</p>

<p>Generally, it's useful to think of such things as genie wishes: your software only gets 3 total. If you're going to use a new framework or language, there should be a strong reason for it; one that current tried and true best practices are unable to solve. There are many fads in software, and its important to sort them out from pivotal changes that move through industries.</p>

<h3>Mobility</h3>

<p>Happy Software has the best chances of reaching maturity and stability when developed by professionals. A professional is more than someone who can do the work; it is someone who can do the work well, and is striving to do better. While the amount of money paid is not a direct correlation to professionalism, it's certainly a useful metric. You don't get happy software by being cheap; you get it by investing time and money into its growth.</p>

<p>The professionals who build your software should be improving its maintainability and lowering the bar for other professionals to take over who are less experienced. The people who build buildings are not the same people who sweep the floors after its built, and the same holds true with software. As your software grows and matures, its needs will become more detailed and nuanced. Difficult problems will be solved, laying way for easier problems to be solved. Its important these transitions be able to take place.</p>

<h2>Things you can do</h2>

<h3>Talk with your professionals</h3>

<p>Communicate your desires and establish with them how things will look in the next few months to the next several years or longer; both given current course and in an ideal world. Also Identify their involvement and how best to position for any transitions.</p>

<h3>Do Nothing</h3>

<p>Sometimes inaction is the best action. If things are manageable and the risks are known and understood, sometimes doing nothing is the right call. Software happiness is not a short term solution, but a long term one. However, Software rarely exists in a bubble, and the slightest change to any one of hundreds or thousands of other dependencies can cause a chain reaction of failure that result in loss of revenue, customers, or data.</p>

<h3>Hire an advocate</h3>

<p>Creating a better future for your software is no easy task, especially if you are not involved in its development. professionals make mistakes, or underperform, and its hard to tell the state of things if you're not in the industry. So whats the solution? Hire an advocate. Having an unbiased party involved ensures that all priorities are being met appropriately, and that the app is heading in the right direction for its short and long term goals.</p>

<h3>Hire Me</h3>

<p>I'll work with you and your professionals to improve the well being of your app and make sure it gets the attention it needs to prosper in the short term and long.</p>

<p>Hourly rate is $225 per hour
Weekly rate is $7k per week</p>

<p>email r.hire@ruru.name for more information.<p><a rel="bookmark" href="http://meesterdude.github.com/entries/how-to-raise-a-happy-well-adjusted-app-principles-for-software-parenting/">&infin; Permalink</a></p></p>
]]></content>
    </entry>
  
</feed>

